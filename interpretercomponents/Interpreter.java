package interpretercomponents;

import java.util.List;

public class Interpreter {
    // list of tokens generated by the Tokenizer
    private final List<Token> tokens;
    // current token index in the list of tokens
    private int currentTokenIndex;
    // variables map which stores identifiers and their values
    private final VariableStorage variables;

    // constructor initializes the interpreter with the input code
    public Interpreter(String input) {
        // create a tokenizer to tokenize the input code
        Tokenizer tokenizer = new Tokenizer(input);
        // tokenize the input and store the resulting tokens in a tokens list
        this.tokens = tokenizer.tokenize();
        // start at the first token in the list
        this.currentTokenIndex = 0;
        // create variables map to track variable assignments
        this.variables = new VariableStorage();
    }

    // get current token without advancing to the next one
    private Token getCurrentToken() {
        return this.tokens.get(this.currentTokenIndex);
    }

    // advance to the next token and return the current one
    private Token getNextToken() {
        return this.tokens.get(this.currentTokenIndex++);
    }

    // check if the current token matches the expected type
    private void checkTokenType(String expectedType) {
        if (!this.getCurrentToken().getType().equals(expectedType)) {
            throw new IllegalArgumentException("Expected " + expectedType + " but got " + this.getCurrentToken().getType());
        }
    }

    // execute all statements in the input code (line-by-line) until the EOF (end of file) token is reached
    public void execute() {
        while (!this.getCurrentToken().getType().equals(Token.EOF)) {
            // execute each statement individually
            this.executeStatement();
        }
    }

    // execute a single statement based on its type
    private void executeStatement() {
        // get the next token from the tokens list
        Token token = this.getNextToken();

        // check if the token type is an identifier (e.g "x" or "number")
        if (token.getType().equals(Token.IDENTIFIER)) {
            // handle variable assignment
            this.handleAssignment(token);
            // check if the token type is keyword (e.g "if")
        } else if (token.getType().equals(Token.KEYWORD)) {
            switch (token.getValue()) {
                case "if":
                    // handle if conditional
                    this.handleIf();
                    break;
                case "while":
                    // handle while conditional
                    this.handleWhile();
                    break;
                case "puts":
                    // handle puts conditional
                    this.handlePuts();
                    break;
                case "break":
                    // handle break statement
                    this.handleBreak();
                    break;
                case "end":
                    // ignore end tokens because they simply mark the end of a block
                    break;
                default:
                    // handle unexpected keywords
                    throw new IllegalArgumentException("Unexpected keyword: " + token.getValue());
            }
        } else if (token.getType().equals(Token.DELIMITER)) {
            // ignore delimiters as they are handled by block methods
        } else {
            // handle unexpected tokens
            throw new IllegalArgumentException("Unexpected token: " + token);
        }
    }

    // handle variable assignments
    private void handleAssignment(Token identifierToken) {
        // ensure that the next token is an assignment operator
        this.checkTokenType(Token.OPERATOR);
        // skip the assignment operator
        this.getNextToken();
        // evaluate right-hand side of the assignment
        Object value = this.eval();
        // store the variable and its value in the variables map
        this.variables.PutVariable(identifierToken.getValue(), value);
    }

    // handle if conditional statement
    private void handleIf() {
        // evaluate the condition
        Object condition = this.eval();
        // ensure the next token is a block delimiter
        this.checkTokenType(Token.DELIMITER);
        // skip the starting block delimiter {
        this.getNextToken();

        boolean conditionMet = (int) condition != 0;
        if (conditionMet) {
            // execute the block if the condition is true
            executeBlock();
        } else {
            // skip the block if the condition is false
            skipBlock();
        }

        // check for the else block
        if (this.getCurrentToken().getType().equals(Token.KEYWORD) && this.getCurrentToken().getValue().equals("else")) {
            // consume the else keyword
            this.getNextToken();

            if (this.getCurrentToken().getType().equals(Token.DELIMITER) && this.getCurrentToken().getValue().equals(
                    "{")) {
                // skip the opening block delimiter
                this.getNextToken();

                // execute else block only if the condition was not met
                if (!conditionMet) {
                    // execute else block
                    executeBlock();
                } else {
                    // skip the else block
                    skipBlock();
                }
            } else {
                // handle a single statement after else
                executeStatement();
            }
        }
    }

    // handle else conditional statement
    private void handleElse() {
        // ensure the next token is a block delimiter {
        this.checkTokenType(Token.DELIMITER);
        // skip the opening block delimiter
        this.getNextToken();
        // execute the else block
        this.executeBlock();
    }

    // handle while loops
    private void handleWhile() {
        // save the start of the loop condition
        int loopStart = this.currentTokenIndex;

        while (true) {
            // reset to the start of the loop condition
            this.currentTokenIndex = loopStart;
            // evaluate the loop condition
            Object condition = this.eval();

            // if the condition is false, exit the loop
            if ((int) condition == 0) {
                // skip the block of code
                this.skipBlock();
                break;
            }

            // ensure the next token is a block delimiter {
            this.checkTokenType(Token.DELIMITER);
            // consume the opening block delimiter
            this.getNextToken();

            try {
                // execute the block of code
                this.executeBlock();
            } catch (BreakException e) {
                // break out of the loop if a break statement is encountered
                break;
            }
        }
    }

    // handle printing to the console
    private void handlePuts() {
        // evaluate the expression to be printed
        Object value = this.eval();
        // print the result to the console
        System.out.println(value);
    }

    // execute the block of code enclosed within curly braces {} or ending with "end"
    private void executeBlock() {
        while (!this.getCurrentToken().getValue().equals(Token.END) && !this.getCurrentToken().getValue().equals("}")) {
            // execute each statement in the block
            this.executeStatement();
        }
        // skip the "end" or the closing curly bracket
        this.getNextToken();
    }

    // skip a block of code without executing it
    private void skipBlock() {
        // start with one open brace
        int openBraces = 1;
        // skip the initial opening curly brace
        this.getNextToken();

        while (openBraces > 0 && this.currentTokenIndex < this.tokens.size()) {
            if (this.getCurrentToken().getValue().equals("{")) {
                // increment for nested block
                openBraces++;
            } else if (this.getCurrentToken().getValue().equals("}")) {
                // decrement for closing brace
                openBraces--;
            }
            // move to the next token
            this.getNextToken();
        }
    }

    // handle break statements in while loops
    private void handleBreak() {
        throw new BreakException();
    }

    // evaluate the expression and return its value
    private Object eval() {
        Token token = this.getNextToken();
        Object result;

        // handle numeric literals
        if (token.getType().equals(Token.NUMBER)) {
            result = Integer.parseInt(token.getValue());
            // handle string literals
        } else if (token.getType().equals(Token.STRING)) {
            result = token.getValue();
            // handle variable references
        } else if (token.getType().equals(Token.IDENTIFIER)) {
            result = variables.getVariable(token.getValue());
        } else {
            // handle unexpected tokens in expression
            throw new IllegalArgumentException("Unexpected token in expression: " + token);
        }

        // process any operators that follow the initial value
        while (this.getCurrentToken().getType().equals(Token.OPERATOR)) {
            // get the operator token
            Token operatorToken = this.getNextToken();
            // evaluate the next value in the expression
            Object nextValue = this.eval();
            // perform operation based on the operator
            switch (operatorToken.getValue()) {
                // handle less-than operation
                case "<":
                    result = (int) result < (int) nextValue ? 1 : 0;
                    break;
                // handle less-than or equal operation
                case "<=":
                    result = (int) result <= (int) nextValue ? 1 : 0;
                    break;
                // handle greater-than operation
                case ">":
                    result = (int) result > (int) nextValue ? 1 : 0;
                    break;
                // handle greater-than or equal operation
                case ">=":
                    result = (int) result >= (int) nextValue ? 1 : 0;
                    break;
                // handle equality operation
                case "==":
                    result = result.equals(nextValue) ? 1 : 0;
                    break;
                // handle not equal operation
                case "!=":
                    result = !result.equals(nextValue) ? 1 : 0;
                    break;
                // handle addition operation
                case "+":
                    if (result instanceof Integer && nextValue instanceof Integer) {
                        result = (int) result + (int) nextValue;
                    } else {
                        result = result.toString() + nextValue.toString();
                    }
                    break;
                // handle subtraction operation
                case "-":
                    result = (int) result - (int) nextValue;
                    break;
                // handle multiplication operation
                case "*":
                    result = (int) result * (int) nextValue;
                    break;
                // handle division operation
                case "/":
                    if ((int) nextValue == 0) {
                        throw new ArithmeticException("Division by zero not allowed");
                    } else {
                        result = (int) result / (int) nextValue;
                    }
                    break;
                // handle modulus operation
                case "%":
                    if ((int) nextValue == 0) {
                        throw new ArithmeticException("Modulus by zero not allowed");
                    } else {
                        result = (int) result % (int) nextValue;
                    }
                    break;
                // handle unexpected operators
                default:
                    throw new IllegalArgumentException("Unexpected operator: " + operatorToken.getValue());
            }
        }

        // return the evaluated result
        return result;
    }
}
