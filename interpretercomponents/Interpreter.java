package interpretercomponents;

import java.util.List;

public class Interpreter {
    private final List<Token> tokens;       // List of tokens generated by the tokenizer.
    private int currentTokenIndex;    // Current index in the list of tokens.
    private final VariableStorage environment;  // The environment stores variable values.

    // Constructor initializes the interpreter with the input code.
    public Interpreter(String input) {
        Tokenizer tokenizer = new Tokenizer(input); // Create a tokenizer to process the input code.
        this.tokens = tokenizer.tokenize();        // Tokenize the input and store the resulting tokens.
        this.currentTokenIndex = 0;                // Start at the first token in the list.
        this.environment = new VariableStorage();      // Create a new environment to track variable assignments.
    }

    // Get the current token without advancing the token index.
    private Token currentToken() {
        return tokens.get(currentTokenIndex);
    }

    // Advance to the next token and return the current one.
    private Token nextToken() {
        return tokens.get(currentTokenIndex++);
    }

    // Check if the current token matches the expected type.
    private void expect(String expectedType) {
        if (!currentToken().getType().equals(expectedType)) {
            throw new IllegalArgumentException("Expected " + expectedType + " but found " + currentToken().getType());
        }
    }

    // Execute all statements in the input code until the EOF token is reached.
    public void execute() {
        while (!currentToken().getType().equals(Token.EOF)) {
            executeStatement(); // Execute each statement individually.
        }
    }

    // Execute a single statement based on its type.
    private void executeStatement() {
        Token token = nextToken(); // Get the next token.

        // Check if the token is an identifier (e.g., a variable name).
        if (token.getType().equals(Token.IDENTIFIER)) {
            handleAssignment(token); // Handle variable assignment.
        }
        // Check if the token is a keyword (e.g., "if", "while").
        else if (token.getType().equals(Token.KEYWORD)) {
            switch (token.getValue()) {
                case "if":
                    handleIf(); // Handle an "if" statement.
                    break;
                case "while":
                    handleWhile(); // Handle a "while" loop.
                    break;
                case "puts":
                    handlePuts(); // Handle a "puts" statement (output to console).
                    break;
                case "end":
                    // Ignore "end" tokens since they simply mark the end of a block.
                    break;
                default:
                    throw new IllegalArgumentException("Unexpected keyword: " + token.getValue());
            }
        }
        // Handle unexpected tokens.
        else {
            throw new IllegalArgumentException("Unexpected token: " + token);
        }
    }

    // Handle variable assignment statements (e.g., x = 5).
    private void handleAssignment(Token identifierToken) {
        expect(Token.OPERATOR); // Ensure the next token is an assignment operator "=".
        nextToken(); // Skip the "=" operator.
        Object value = evaluateExpression(); // Evaluate the right-hand side of the assignment.
        environment.PutVariable(identifierToken.getValue(), value); // Store the variable and its value in the
        // environment.
    }

    // Handle "if" statements.
    private void handleIf() {
        Object condition = evaluateExpression(); // Evaluate the condition
        expect(Token.DELIMITER); // Ensure the next token is a block delimiter ("{")
        nextToken(); // Skip the "{" delimiter

        boolean conditionMet = (int) condition != 0;
        if (conditionMet) {
            executeBlock(); // Execute the block if the condition is true
        } else {
            skipBlock(); // Skip the block if the condition is false
        }

        // Check for the "else" block
        if (currentToken().getType().equals(Token.KEYWORD) && currentToken().getValue().equals("else")) {
            nextToken(); // Consume the "else" keyword

            if (currentToken().getType().equals(Token.DELIMITER) && currentToken().getValue().equals("{")) {
                nextToken(); // Skip the "{" delimiter

                if (!conditionMet) { // Execute "else" block only if the "if" condition was not met
                    executeBlock(); // Execute the "else" block
                } else {
                    skipBlock(); // Skip the "else" block
                }
            } else {
                executeStatement(); // Handle a single statement after "else"
            }
        }
    }

    // Handle "else" blocks.
    private void handleElse() {
        expect(Token.DELIMITER); // Ensure the next token is a block delimiter ("{").
        nextToken(); // Skip the "{" delimiter.
        executeBlock(); // Execute the "else" block.
    }

    // Handle "while" loops.
    private void handleWhile() {
        int loopStart = currentTokenIndex; // Save the start of the loop condition.

        while (true) {
            currentTokenIndex = loopStart; // Reset to the start of the loop condition.
            Object condition = evaluateExpression(); // Evaluate the loop condition.

            if ((int) condition == 0) { // If the condition is false, exit the loop.
                skipBlock(); // Skip the block of code.
                break;
            }

            expect(Token.DELIMITER); // Ensure the next token is '{'.
            nextToken(); // Consume the '{'.

            executeBlock(); // Execute the block of code.
        }
    }

    // Handle "puts" statements (print to console).
    private void handlePuts() {
        Object value = evaluateExpression(); // Evaluate the expression to be printed.
        System.out.println(value); // Print the result to the console.
    }

    // Execute a block of code enclosed by "{" and "}" or ending with "end".
    private void executeBlock() {
        while (!currentToken().getValue().equals("end") && !currentToken().getValue().equals("}")) {
            executeStatement(); // Execute each statement in the block
        }
        nextToken(); // Skip the "end" or "}" token
    }

    // Skip a block of code without executing it.
    private void skipBlock() {
        int openBraces = 1; // Start with one open brace '{'
        nextToken(); // Skip the initial '{'

        while (openBraces > 0) {
            if (currentToken().getValue().equals("{")) {
                openBraces++; // Increment for nested block
            } else if (currentToken().getValue().equals("}")) {
                openBraces--; // Decrement for closing brace
            }
            nextToken(); // Move to the next token
        }
    }

    // Evaluate an expression and return its value.
    private Object evaluateExpression() {
        Token token = nextToken(); // Get the next token.
        Object result;

        // Handle numeric literals.
        if (token.getType().equals(Token.NUMBER)) {
            result = Integer.parseInt(token.getValue());
        }
        // Handle string literals.
        else if (token.getType().equals(Token.STRING)) {
            result = token.getValue();
        }
        // Handle variable references.
        else if (token.getType().equals(Token.IDENTIFIER)) {
            result = environment.getVariable(token.getValue());
        }
        // Handle unexpected tokens in expressions.
        else {
            throw new IllegalArgumentException("Unexpected token in expression: " + token);
        }

        // Process any operators that follow the initial value.
        while (currentToken().getType().equals(Token.OPERATOR)) {
            Token operatorToken = nextToken(); // Get the operator token.
            Object nextValue = evaluateExpression(); // Evaluate the next value in the expression.

            // Perform the operation based on the operator.
            switch (operatorToken.getValue()) {
                case "<":
                    result = (int) result < (int) nextValue ? 1 : 0;
                    break;
                case "<=":
                    result = (int) result <= (int) nextValue ? 1 : 0;
                    break;
                case ">":
                    result = (int) result > (int) nextValue ? 1 : 0;
                    break;
                case ">=":
                    result = (int) result >= (int) nextValue ? 1 : 0;
                    break;
                case "==":
                    result = result.equals(nextValue) ? 1 : 0;
                    break;
                case "!=":
                    result = !result.equals(nextValue) ? 1 : 0;
                    break;
                case "+":
                    if (result instanceof Integer && nextValue instanceof Integer) {
                        result = (int) result + (int) nextValue; // Numeric addition.
                    } else {
                        result = result.toString() + nextValue.toString(); // String concatenation.
                    }
                    break;
                case "-":
                    result = (int) result - (int) nextValue; // Subtraction.
                    break;
                case "*":
                    result = (int) result * (int) nextValue; // Multiplication.
                    break;
                case "/":
                    if ((int) nextValue == 0) {
                        throw new ArithmeticException("Division by zero is not allowed."); // Handle division by zero.
                    }
                    result = (int) result / (int) nextValue; // Division.
                    break;
                case "%":
                    if ((int) nextValue == 0) {
                        throw new ArithmeticException("Modulus by zero is not allowed."); // Handle modulus by zero.
                    }
                    result = (int) result % (int) nextValue; // Modulus.
                    break;
                default:
                    throw new IllegalArgumentException("Unexpected operator: " + operatorToken.getValue());
            }
        }

        return result; // Return the final result of the expression.
    }

}
